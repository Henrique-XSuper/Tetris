<!DOCTYPE html>
<html lang="pt-br">
 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris RetrÃ´ Neon - Mobile</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a0033, #330066, #1a0033);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #ccffff;
            font-family: 'Press Start 2P', cursive, monospace;
            text-shadow: 0 0 5px #00ffff;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }
 
        .game-container {
            background-color: #00000099;
            border-radius: 8px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 25px #00ffffb3;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            overflow: hidden;
            max-width: 100vw;
            max-height: 100vh;
        }
 
        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(black 0px, black 1px, gray 1px, gray 2px);
            opacity: 0.2;
            pointer-events: none;
        }
 
        .game-area {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: flex-start;
        }
 
        canvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 15px #00ffffe6, inset 0 0 8px #00ffff;
            background-color: black;
            image-rendering: pixelated;
        }
 
        .ui-panel {
            min-width: 120px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
 
        .ui-panel h2 {
            font-size: 10px;
            color: #99ffff;
            text-shadow: 0 0 8px #00ffff;
            margin: 0;
            font-family: 'Press Start 2P', cursive, monospace;
        }
 
        #score,
        #next-piece-container {
            background-color: black;
            border: 1px solid #00ffff;
            padding: 8px;
            border-radius: 3px;
            text-align: center;
            width: 100%;
            box-shadow: 0 0 8px #00ffff, inset 0 0 3px #00ffff;
            font-size: 12px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', monospace;
        }
 
        #next-piece-container {
            min-height: 80px;
        }
 
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            z-index: 10;
            margin-top: 10px;
        }
 
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
 
        .control-btn {
            background: linear-gradient(145deg, #003366, #001133);
            border: 2px solid #00ffff;
            color: #00ffff;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 0 10px #00ffff66, inset 0 0 5px #00ffff33;
            cursor: pointer;
            transition: all 0.1s;
            text-shadow: 0 0 5px #00ffff;
            min-width: 50px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }
 
        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px #00ffff, inset 0 0 10px #00ffff66;
            background: linear-gradient(145deg, #004488, #002244);
        }
 
        .control-btn.rotate {
            border-radius: 50%;
            width: 60px;
            height: 60px;
        }
 
        .control-btn.drop {
            background: linear-gradient(145deg, #660033, #330011);
            border-color: #ff00ff;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            box-shadow: 0 0 10px #ff00ff66, inset 0 0 5px #ff00ff33;
            width: 80px;
        }
 
        .control-btn.drop:active {
            box-shadow: 0 0 15px #ff00ff, inset 0 0 10px #ff00ff66;
            background: linear-gradient(145deg, #880044, #440022);
        }
 
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #ff0077;
            display: none;
            text-shadow: 0 0 15px #ff0077, 0 0 25px #ff0077;
            text-align: center;
            animation: flicker 1.5s infinite alternate;
            font-family: 'Press Start 2P', cursive, monospace;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ff0077;
        }
 
        #game-over small {
            font-size: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-family: 'Press Start 2P', cursive, monospace;
        }
 
        @keyframes flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                text-shadow:
                0 0 15px #ff0077,
                0 0 25px #ff0077,
                0 0 40px #ff0077;
                opacity: 1;
            }
            20%, 24%, 55% {
                text-shadow: none;
                opacity: 0.8;
            }
        }
        
        /* Ajustes responsivos */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .game-container {
                padding: 10px;
                gap: 10px;
            }
            
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .ui-panel {
                flex-direction: row;
                min-width: auto;
                gap: 20px;
                justify-content: space-around;
                width: 100%;
            }
            
            #game-over {
                font-size: 16px;
                padding: 15px;
            }
            
            #game-over small {
                font-size: 8px;
            }
        }
        
        @media (max-height: 600px) {
            .control-btn {
                min-width: 40px;
                min-height: 40px;
                font-size: 8px;
                padding: 8px;
            }
            
            .control-btn.rotate {
                width: 50px;
                height: 50px;
            }
            
            .control-btn.drop {
                width: 70px;
            }
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="game-area">
        <canvas id="tetrisCanvas" width="240" height="480"></canvas>
        <div class="ui-panel">
            <div>
                <h2>PONTUAÃ‡ÃƒO</h2>
                <div id="score">0</div>
            </div>
            <div>
                <h2>PRÃ“XIMA</h2>
                <div id="next-piece-container">
                    <canvas id="nextPieceCanvas" width="80" height="80"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <div class="control-row">
            <button class="control-btn rotate" id="rotateBtn">ðŸ”„</button>
        </div>
        <div class="control-row">
            <button class="control-btn" id="leftBtn">â—€</button>
            <button class="control-btn" id="downBtn">â–¼</button>
            <button class="control-btn" id="rightBtn">â–¶</button>
        </div>
        <div class="control-row">
            <button class="control-btn drop" id="dropBtn">DROP</button>
        </div>
    </div>
    
    <div id="game-over">GAME OVER<br><small>Toque para reiniciar</small></div>
</div>

<script>
    // ObtÃ©m as referÃªncias para os elementos canvas e seus contextos de desenho 2D.
    const canvas = document.getElementById('tetrisCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextPieceCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    // ObtÃ©m as referÃªncias para os elementos HTML de pontuaÃ§Ã£o e "GAME OVER".
    const scoreDisplay = document.getElementById('score');
    const gameOverDisplay = document.getElementById('game-over');
    
    // BotÃµes de controle mobile
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const downBtn = document.getElementById('downBtn');
    const rotateBtn = document.getElementById('rotateBtn');
    const dropBtn = document.getElementById('dropBtn');

    // Define as dimensÃµes do tabuleiro de Tetris (linhas e colunas).
    const ROWS = 20;
    const COLS = 10;
    // Define o tamanho de cada bloco em pixels (menor para mobile).
    const BLOCK_SIZE = 24;

    // Inicializa o tabuleiro como uma matriz 2D preenchida com zeros (representando espaÃ§os vazios).
    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    // Inicializa a pontuaÃ§Ã£o do jogo.
    let score = 0;
    // VariÃ¡vel booleana para controlar o estado do jogo (se terminou ou nÃ£o).
    let isGameOver = false;

    // Cores das peÃ§as de Tetris, ajustadas para um estilo retrÃ´ neon.
    const colors = [
        '#00ffff', /* Ciano */
        '#0099ff', /* Azul elÃ©trico */
        '#ff9900', /* Laranja vÃ­vido */
        '#ffff00', /* Amarelo clÃ¡ssico */
        '#00ff00', /* Verde lima */
        '#ff00ff', /* Magenta */
        '#ff3300'  /* Vermelho vibrante */
    ];

    // DefiniÃ§Ãµes das formas das peÃ§as de Tetris, representadas como matrizes 2D.
    const shapes = [
        [[1, 1, 1, 1]],           // PeÃ§a "I"
        [[1, 0, 0], [1, 1, 1]],   // PeÃ§a "J"
        [[0, 0, 1], [1, 1, 1]],   // PeÃ§a "L"
        [[1, 1], [1, 1]],         // PeÃ§a "O"
        [[0, 1, 1], [1, 1, 0]],   // PeÃ§a "S"
        [[0, 1, 0], [1, 1, 1]],   // PeÃ§a "T"
        [[1, 1, 0], [0, 1, 1]]    // PeÃ§a "Z"
    ];

    // VariÃ¡veis para armazenar a peÃ§a atual e a prÃ³xima peÃ§a.
    let currentPiece, nextPiece;
    // VariÃ¡veis para as coordenadas (x, y) da peÃ§a atual no tabuleiro.
    let currentPieceX, currentPieceY;

    // FunÃ§Ã£o para gerar uma peÃ§a de Tetris aleatÃ³ria.
    function getRandomPiece() {
        // Seleciona um Ã­ndice de forma aleatoriamente.
        const shapeIndex = Math.floor(Math.random() * shapes.length);
        // Retorna um objeto contendo a forma e a cor correspondente.
        return {
            shape: shapes[shapeIndex],
            color: colors[shapeIndex]
        };
    }

    // FunÃ§Ã£o para iniciar um novo jogo.
    function newGame() {
        // Reinicia o tabuleiro, preenchendo-o com zeros.
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        // Zera a pontuaÃ§Ã£o.
        score = 0;
        // Reseta o estado de "game over".
        isGameOver = false;
        // Oculta a mensagem de "game over".
        gameOverDisplay.style.display = 'none';
        // Atualiza a exibiÃ§Ã£o da pontuaÃ§Ã£o para 0.
        scoreDisplay.textContent = '0';
        // Gera a primeira prÃ³xima peÃ§a.
        nextPiece = getRandomPiece();
        // Spawna a primeira peÃ§a no tabuleiro.
        spawnPiece();
    }

    // FunÃ§Ã£o para "spawna" (gerar) uma nova peÃ§a no topo do tabuleiro.
    function spawnPiece() {
        // A prÃ³xima peÃ§a se torna a peÃ§a atual.
        currentPiece = nextPiece;
        // Gera uma nova "prÃ³xima peÃ§a".
        nextPiece = getRandomPiece();
        // Define a posiÃ§Ã£o inicial X da peÃ§a (centralizada no topo).
        currentPieceX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
        // Define a posiÃ§Ã£o inicial Y da peÃ§a (topo do tabuleiro).
        currentPieceY = 0;

        // Verifica se a nova peÃ§a colide imediatamente (indicando game over).
        if (checkCollision(currentPiece.shape, currentPieceX, currentPieceY)) {
            // Define o estado do jogo como "game over".
            isGameOver = true;
            // Exibe a mensagem de "game over".
            gameOverDisplay.style.display = 'block';
        }
        // Desenha a prÃ³xima peÃ§a no painel lateral.
        drawNextPiece();
    }

    // FunÃ§Ã£o para desenhar um Ãºnico bloco no canvas.
    function drawBlock(x, y, color, context, size) {
        // Se a cor for 0, significa que o bloco estÃ¡ vazio, entÃ£o nÃ£o desenha nada.
        if (color === 0) return;
        // Define a cor de preenchimento do bloco.
        context.fillStyle = color;
        // Define a cor para a sombra (para o efeito neon).
        context.shadowColor = color;
        // Define o nÃ­vel de desfoque da sombra.
        context.shadowBlur = 8;
        // Desenha o retÃ¢ngulo preenchido que representa o bloco.
        context.fillRect(x * size, y * size, size, size);
        // Reseta o desfoque da sombra para nÃ£o afetar desenhos posteriores.
        context.shadowBlur = 0;
        // Define a cor da borda do bloco como preta para destaque.
        context.strokeStyle = 'black';
        // Define a largura da borda.
        context.lineWidth = 1.5;
        // Desenha o contorno do retÃ¢ngulo.
        context.strokeRect(x * size, y * size, size, size);
    }

    // FunÃ§Ã£o para desenhar todo o tabuleiro.
    function drawBoard() {
        // Limpa todo o canvas do tabuleiro.
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Itera sobre cada cÃ©lula do tabuleiro.
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                // Desenha cada bloco com base no valor armazenado na matriz 'board'.
                drawBlock(x, y, board[y][x], ctx, BLOCK_SIZE);
            }
        }
    }

    // FunÃ§Ã£o para desenhar a peÃ§a atual em sua posiÃ§Ã£o.
    function drawPiece() {
        // Itera sobre cada linha e coluna da forma da peÃ§a atual.
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                // Se o valor for 1 (representa um bloco da peÃ§a), desenha-o.
                if (value) {
                    drawBlock(currentPieceX + x, currentPieceY + y, currentPiece.color, ctx, BLOCK_SIZE);
                }
            });
        });
    }

    // FunÃ§Ã£o para desenhar a prÃ³xima peÃ§a no painel lateral.
    function drawNextPiece() {
        // Limpa o canvas da prÃ³xima peÃ§a.
        nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
        const shape = nextPiece.shape;
        // Calcula a posiÃ§Ã£o inicial para centralizar a prÃ³xima peÃ§a no canvas.
        const startX = (nextCanvas.width / BLOCK_SIZE - shape[0].length) / 2;
        const startY = (nextCanvas.height / BLOCK_SIZE - shape.length) / 2;
        // Itera sobre a forma da prÃ³xima peÃ§a e desenha seus blocos.
        shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    drawBlock(startX + x, startY + y, nextPiece.color, nextCtx, BLOCK_SIZE);
                }
            });
        });
    }

    // FunÃ§Ã£o para verificar se uma peÃ§a colide com as bordas do tabuleiro ou com outras peÃ§as jÃ¡ assentadas.
    function checkCollision(pieceShape, x, y) {
        // Itera sobre a forma da peÃ§a.
        for (let row = 0; row < pieceShape.length; row++) {
            for (let col = 0; col < pieceShape[row].length; col++) {
                // Verifica se a cÃ©lula atual da peÃ§a existe (valor 1) E se hÃ¡ colisÃ£o:
                if (pieceShape[row][col] &&
                    (x + col < 0 || x + col >= COLS || y + row >= ROWS || (board[y + row] && board[y + row][x + col]))) {
                    return true; // ColisÃ£o detectada.
                }
            }
        }
        return false; // Nenhuma colisÃ£o.
    }

    // FunÃ§Ã£o para "fundir" (merge) a peÃ§a atual com o tabuleiro quando ela atinge o fundo ou outra peÃ§a.
    function mergePiece() {
        // Itera sobre a forma da peÃ§a atual.
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                // Se o valor for 1, significa que Ã© um bloco da peÃ§a.
                if (value) {
                    // Copia a cor do bloco para a posiÃ§Ã£o correspondente no tabuleiro.
                    board[currentPieceY + y][currentPieceX + x] = currentPiece.color;
                }
            });
        });
        // Verifica se alguma linha foi completada.
        checkLines();
        // Spawna uma nova peÃ§a.
        spawnPiece();
    }

    // FunÃ§Ã£o para verificar e limpar linhas completas no tabuleiro.
    function checkLines() {
        let linesCleared = 0; // Contador de linhas limpas.
        // Itera de baixo para cima no tabuleiro.
        for (let y = ROWS - 1; y >= 0; y--) {
            // Verifica se a linha atual estÃ¡ completamente preenchida (nenhuma cÃ©lula Ã© 0).
            if (board[y].every(cell => cell !== 0)) {
                // Remove a linha completa do tabuleiro.
                board.splice(y, 1);
                // Adiciona uma nova linha vazia no topo do tabuleiro.
                board.unshift(Array(COLS).fill(0));
                // Incrementa o contador de linhas limpas.
                linesCleared++;
                // Incrementa 'y' para verificar a mesma nova linha (que agora desceu) na prÃ³xima iteraÃ§Ã£o.
                y++;
            }
        }
        // Se alguma linha foi limpa, atualiza a pontuaÃ§Ã£o.
        if (linesCleared > 0) {
            score += linesCleared * 100; // Cada linha vale 100 pontos.
            scoreDisplay.textContent = score; // Atualiza a exibiÃ§Ã£o da pontuaÃ§Ã£o.
        }
    }

    // FunÃ§Ã£o para rotacionar a peÃ§a atual.
    function rotatePiece() {
        const originalShape = currentPiece.shape; // Guarda a forma original antes de rotacionar.
        // Cria uma nova forma rotacionada 90 graus no sentido horÃ¡rio.
        const newShape = originalShape[0].map((_, colIndex) => originalShape.map(row => row[colIndex]).reverse());

        // Tenta rotacionar a peÃ§a na posiÃ§Ã£o atual. Se nÃ£o houver colisÃ£o, aplica a rotaÃ§Ã£o.
        if (!checkCollision(newShape, currentPieceX, currentPieceY)) {
            currentPiece.shape = newShape;
        } else {
            // Se houver colisÃ£o, tenta "chutar" a peÃ§a para os lados para ver se ela se encaixa.
            for (let i = 1; i <= newShape[0].length; i++) {
                // Tenta mover para a direita.
                if (!checkCollision(newShape, currentPieceX + i, currentPieceY)) {
                    currentPiece.shape = newShape;
                    currentPieceX += i;
                    return;
                }
                // Tenta mover para a esquerda.
                if (!checkCollision(newShape, currentPieceX - i, currentPieceY)) {
                    currentPiece.shape = newShape;
                    currentPieceX -= i;
                    return;
                }
            }
        }
    }

    // FunÃ§Ãµes de movimento
    function moveLeft() {
        if (isGameOver) return;
        if (!checkCollision(currentPiece.shape, currentPieceX - 1, currentPieceY)) {
            currentPieceX--;
        }
    }

    function moveRight() {
        if (isGameOver) return;
        if (!checkCollision(currentPiece.shape, currentPieceX + 1, currentPieceY)) {
            currentPieceX++;
        }
    }

    function moveDown() {
        if (isGameOver) return;
        currentPieceY++;
        if (checkCollision(currentPiece.shape, currentPieceX, currentPieceY)) {
            currentPieceY--;
            mergePiece();
        }
    }

    function hardDrop() {
        if (isGameOver) return;
        while (!checkCollision(currentPiece.shape, currentPieceX, currentPieceY + 1)) {
            currentPieceY++;
        }
        mergePiece();
    }

    function rotate() {
        if (isGameOver) return;
        rotatePiece();
    }

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;

    // FunÃ§Ã£o principal do loop do jogo.
    function gameLoop(time = 0) {
        if (isGameOver) return;
        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            currentPieceY++;
            if (checkCollision(currentPiece.shape, currentPieceX, currentPieceY)) {
                currentPieceY--;
                mergePiece();
            }
            dropCounter = 0;
        }

        drawBoard();
        drawPiece();
        requestAnimationFrame(gameLoop);
    }

    // Event listeners para controles mobile
    leftBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveLeft();
    });

    rightBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveRight();
    });

    downBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveDown();
    });

    rotateBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        rotate();
    });

    dropBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        hardDrop();
    });

    // Suporte para clique do mouse tambÃ©m
    leftBtn.addEventListener('click', moveLeft);
    rightBtn.addEventListener('click', moveRight);
    downBtn.addEventListener('click', moveDown);
    rotateBtn.addEventListener('click', rotate);
    dropBtn.addEventListener('click', hardDrop);

    // Event listener para teclado (para desktops)
    document.addEventListener('keydown', (e) => {
        if (isGameOver) {
            if (e.key === 'r' || e.key === 'R') {
                newGame();
                gameLoop();
            }
            return;
        }

        switch(e.key) {
            case 'ArrowLeft':
                moveLeft();
                break;
            case 'ArrowRight':
                moveRight();
                break;
            case 'ArrowDown':
                moveDown();
                break;
            case 'ArrowUp':
                rotate();
                break;
            case ' ':
                e.preventDefault();
                hardDrop();
                break;
        }
    });

    // Reiniciar jogo ao tocar em game over
    gameOverDisplay.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (isGameOver) {
            newGame();
            gameLoop();
        }
    });

    gameOverDisplay.addEventListener('click', () => {
        if (isGameOver) {
            newGame();
            gameLoop();
        }
    });

    // Prevenir zoom no mobile
    document.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, false);

    // Inicia o jogo
    newGame();
    gameLoop();
</script>
</body>
</html>
